# **目录**
* [**基本内置类型**](#1)
  1. 算数类型
  2. 类型转换
  3. 字面值常量
* [**变量**](#2)
  1. 变量定义
  2. 变量声明
  3. 标识符
* [**复合类型**](#3)
  1. 引用
  2. 指针
  3. 理解复合类型的声明
  </details>
* [**const限定符**](#4)
  1. const的引用
  2. 指针和const
  3. 顶层const
  4. constexpr和常量表达式
* [**处理类型**](#5)
  1. 类型别名
  2. auto
  3. decltype
* ***
# 基本内置类型 <span id="1"> </span>
## 1.算数类型
---
|  类型   | 含义  | 最小尺寸 |
|  ----  | ----  | --- |
| bool  | 布尔类型 | ub |
| char  | 字符 | 8 |
| wchar_t | 宽字符 | 16 |
| char16_t | Unicode字符 | 16 |
| cahr32_t | Unicode字符 | 32 |
| short | 短整型 | 16 |
| int | 整型 | 16 |
| long | 长整型 | 32 |
| long long | 长整型 | 32 |
| float | 单精度浮点数 | 6位有效数字 |
| double | 双精度浮点数 | 10位有效数字 |
| long double | 扩展精度有效数字 | 10位有效数字 |
---
注释：
* bool的取值为true(真)或false(假)
* 一个char的大小和一个**机器字节**一样
* 一个int至少和一个short一样大,一个long至少和一个int一样大，一个long long至少和一个long一样大
* long long为C++11新定义数据类型
---
带符号类型和无符号类型：
* 除去布尔型和扩展的字符型外，其它整型可划分为带符号的(signed)和无符号的(unsigned)
* 类型unsigned int可以缩写为unsigned
* 字符型被分为三种：char，signed char和unsigned char.尽管有三种，但**表现形式只有两种**：有符号和无符号
* 8bit下：
* unsigned char (0~255) 
* signed char (-128,127)
---
## 2.类型转换
---
自动类型转换：
```c++
bool b = 42;           //b为真
int  i = b ;           //i为1
i = 3.14;              //i为3
double pi = i;         //pi为3.0
unsigned char c = -1;  //(8bit)，c为255
signed char c2 = 256;  //(8bit), c的值未定义
```
未定义的值可能导致程序崩溃，或者生产垃圾数据
***
含有无符号类型的表达式：
```c++
unsigned u =10;
int i = -42;
std::cout << i + i;//-84
std::cout << i + u;//(32bit),4294967264
```
当一个算术表达式中既有无符号数又有int值时，int会自动转换为无符号数。第四行代码,把 i 转换为无符号数的过程为：i + 无符号数的模.(始终不要让无符号数变成负数)
## 3.字面值常量
一个形如42的值被称作字面值常量。每个字面值常量都对应一种数据类型。
***
整型和浮点型字面值:
```c++
20     /* 十进制   */
024    /* 八进制   */
0x14   /* 十六进制 */
```
注释:
* 整型字面值具体的数据类型由它的值和符号决定
* 默认情况下，十进制字面值是带符号数
* 十进制字面值的类型是int、long、long long当中尺寸最小的那个(前提是这种类型可以容纳当前值)
* short没有对应的字面值
***
字符和字符串字面值:
```c++
'a' //字符字面值
'Hello World' //字符串字面值
```
***
转义序列：
| 序列 | 含义 |
| --- | --- |
| \n | 换行符 |
| \v | 纵向制表符 |
| \\ | 反斜线 |
| \r | 回车符 |
| \t | 横向制表符 |
| \b | 退格符 |
| \? | 问号 |
| \a | 进纸符 |
| \" | 报警符 |
| ' | 单引号 |
***
指定字面值的类型（略)   
TODO ADD IT
***
# 变量 <span id="2"> </span>
变量提供一个具名的、可供程序操作的存储空间  
C++中每个变量都有数据类型   
数据类型决定着变量所占内存空间大小和布局方式
***
## 1.变量定义
基本形式：   
<类型说明符> <一个或多个变量名组成的列表>(逗号分隔变量名) <;>  
定义时还可以为一个或多个变量赋初值：
```c++
int a, b = 0,           //a,b,c都是int
    c=0;                //b、c的初始值为0
std::string d("I am d") //d通过一个string字面值初始化
```
***
初始值：  
当对象在创建时获得了一个特定的值时，我们说这个对象被**初始化**了  
注意：初始化和赋值是两个不同的操作，例：
```c++
int a;
a = 0;  //a先被定义再被赋值
int b = 114514;  //b被定义同时初始化
```
***
列表初始化：  
要想使某个变量被初始化为0，下列几条语句都可以做到：
```c++
int num1 = 0;
int num2 = {0};
int num3{0};
int num4(0);
```
如上述，用花括号初始化变量的方式称作列表初始化  
当用于内置类型的变量时，这种初始化形式若存在丢失信息的风险，则编译器会报错，如：
```c++
long double pi = 3.1415926536;
int a{pi}, b{pi}; //错误：转换未执行，因为存在丢失信息的风险
int c(pi), d = pi;//正确：转换执行，且确实丢失了部分值
```
***
默认初始化：  
若定义变量时未指定初值，则变量被默认初始化   
内置类型：  
函数外：被初始化为0  
函数内：**不被初始化**  
每个类将自行决定初始化的方式
***
## 2.变量声明和定义的关系
C++为了支持分离式编译，将声明和定义区分开  
**声明**：使得名字为程序所知  
**定义**：创建与名字关联的实体
若只想声明一个变量而不定义它，在类型名前添加关键词**extern**,而不要显式地定义它:
```c++
extern int i;//声明i而不定义i
int j；      //声明并定义j
extern double pi = 3.14159;//定义，初始化过程抵消了extern关键词
```
在函数体内部，如果试图初始化一个由extern标记的变量，将引发错误  
注:变量能且只能被定义一次，但是可以被多次声明
***
## 3.标识符
* 由字母、数字、下划线组成
* 区分大小写
* 必须以字母或下划线开头、
* 不能使用保留关键字
---
# 复合类型 <span id="3"> </span>
**复合类型**是指基于其它类型定义的类型
***
## 1.引用
**引用**为对象起了另外一个名字  
通过将声明符写成 **&d** 的形式来定义引用类型
```c++
int ival = 1024;    
int &refVal = ival; //refVal是ival的引用（别名）
int &refVal2;       //错误：引用必须被初始化
```
* 定义引用时，程序会把引用和它的初始值**绑定**，而不是拷贝初始值  
所以定义一个引用之后，对其进行的所有操作都是在与之绑定的对象上进行的
* 引用无法重新绑定到其它对象  
* 引用本身不是一个对象，所有不能定义引用的引用
* 引用（左值）的初始值必须是一个对象，形如 **int &a = 10;** 的代码是错误的，因为10不是一个对象
* 除两种[例外情况](#add1)<span id="origin1"> </span>，其它 所有类型的引用都要与之绑定的对象严格匹配
***
## 2.指针
**指针**是指向某一种类型的复合类型，与引用类似，也能实现对象的间接访问  
不同处在于：
* 指针本身就是对象，允许进行赋值和拷贝，也可以指向不同的对象
* 无需再定义时赋值
***
获取变量的地址：  
**指针存放某个对象的地址**，要想获得该地址，用取地址符&
```c++
int a = 10;
int* point = &a;//point存放a的地址，或者说point是指向变量a的指针
```
除后续的两种[例外情况](#add3)<span id="origin2"> </span> ，其它所有指针的类型都要和它指向的对象类型严格匹配
```c++
double b;
double* pd=&b;   //正确：初始值是double型对象的地址
double* pd2=&pd; //正确：初始值是指向double对象的指针
int* pi=pd;      //错误: pi与pd的类型不匹配
pi=b;            //错误：double对象的地址不能赋值给int指针
```
***  
指针值：  
指针的值（地址）应属于下列四种状态之一：
1. 指向一个对象
2. 指向紧邻对象所占空间的下一个位置
3. 空指针，未指向任何对象
4. 无效指针，即上述情况之外的其他值  
   
注释：**访问无效指针**将会引发错误
***  
利用指针访问对象：  
若指针指向一个对象，则使用解引用符（*）来访问对象  
```c++
int ival = 10;
int* p = ival;
std::cout<<*p;  
//输出10
*p = 0;
std::cout<<*p;
//输出0
```
***
空指针：  
**空指针**不指向任何对象。
下列给出几种生成空指针的方法:
```c++
int* p1 = 0;        //直接初始化为字面值0
int* p2 = nullptr;  //C++11中引入的一种方法，nullptr是一种特殊的字面值，可以被转换为任意一种指针类型
int* p3 = NULL;     //(定义于cstdlib) #define NULL 0
```
尽量使用**nullptr**而不是**NULL**
***
赋值和指针：  
指针的赋值有两种情况：    
1. 为指针本身赋值  
2. 为指针指向的对象赋值
   
```c++
int val1 = 10;
int val2 = 20;
int* p1 = val1;
int* p2 = val2;
p1 = p2;   //为p1指针本身赋值
*p2 = 30;  //为指针p2指向的对象赋值
```
***
void* 指针：  
**void***是一种特殊的指针类型，可用于存放 **任意对象的地址** ，这一点于其它指针类似，不同的是，该地址中到底存放何种类型的对象我们并不了解  
```c++
int obj = 10, *pt = &obj;
void* pv = &obj;  //obj可以是任意类型的对象
pv = pt;          //pv可以存放任意类型的指针
```
void* 的视角来看内存空间仅仅是内存空间，而无法访问内存空间中的对象
***
## 3.理解复合类型的声明
指向指针的指针:  
```c++
int ival = 10;
int* p1 =&ival;  //p1是指向ival的指针，指向一个int型的数
int** p2 = &p1;  //p2是指向p1的指针，指向一个int型的指针
```
指向指针的引用：  
引用本身不是对象，所以不能定义指向引用的指针，但是指针本身是变量，所以可以定义 **指向指针的引用**
```c++
int i = 42;
int* p;
int* &r=p;  //r是一个对指针p的引用
r = &i;     //此时p指向i
*r = 0;     //r是p的别名，对r解引用也就是对p解引用，此时p指向的对象i的值被赋值为0
```
***
# 4.const限定符
用const限定的变量（也称为常量）的值不可以被改变，任何试图对其赋值的操作都将引发错误  
也因此，const变量必须初始化
```c++
const int i = 10;          //正确
const int j = get_size();  //正确，初始值可以是任意复杂的表达式
const int k;               //错误，常量定义必须初始化
i = j；                    //错误，常量的值不可以修改
```
***
初始化和const：  
对象的类型决定了其能完成的操作
与非const类型能参与的操作相比，const类型能完成大部分操作，但不是全部，主要的限制是不能修改其值。如：
* const int和int都能参与算数操作
* const int和int都能转换为bool值
  等
* 初始化：如果用一个对象去初始化另一个对象，那它们是不是const都无关紧要
  ```c++
  int i =42;
  const int ci = i;
  int j = ci;
  //上述代码均正确
  ```
***
**默认状况下，const对象仅在文件内有效**  
解决方法：添加**extern**关键字
***
## 1.const的引用
可以把引用绑定到const对象上，就像绑定到其它对象上一样，称为 **常量引用**  
**不能修改其绑定的对象**
***
初始化和对const的引用：  
[前文提到](#origin1)<span id="add1"> </span>引用的类型必须与其所引用的对象类型保持一致，但是有两个例外：  
第一种例外就是在初始化常量引用时允许用任意表达式作为初始值，只要该表达式的结果能转换成引用的类型就行，尤其，允许一个常量引用绑定**非常量的对象**、**字面值**、甚至是**一个一般表达式** 。  
[第二个例外](#add2)
TODO FIX ADD2
***
```C++
int i = 42;
const int& r1 = i;      //允许将const int&绑定到int对象上
const int& r2 = 42;      //允许将const int&绑定到字面值上
const int& r3 = r1 * 2; //允许将const int&绑定到表达式上
int& r4 = r1 * 2;       //错误：r4是非常量引用
```
***
对const的引用可能不是const对象:  
**必须意识到**：常量引用仅对引用可参与的操作做出了限定，对于引用的对象本身是不是常量未作限定  
```c++
int i = 42;
int& r1 = i;        //r1绑定对象i
const int& r2 = i;  //r2也绑定对象i，但是不允许通过r2修改i的值
r1 = 0;             //正确
r2 = 0;             //错误
```
***
## 2.指针和const
**指向常量的指针**不能用于改变其所指对象的值。要想存放常量对象的地址，只能使用指向常量的指针  
```c++
const int v1 = 42;     //v1是常量
int* p1 = &v1;         //错误：p1是普通指针
const int* p2 = &v1;   //正确：p2是指向常量的指针
*p2 = 24;              //错误：不能给*p2赋值
```
[前文提到](#origin2)<span id="add3"> <span>
指针的类型必须与其所指对象的类型保持一致，但是有两个例外，  
第一种例外就是允许令一个指向常量的指针指向非常量对象：
```c++
int v2 = 1024;
p2 = &v2;     //正确：但是不能通过p2改变v2的值
```
[第二种例外](#add4)
TODO FIX ADD4
***
const指针：  
* 指针是对象而引用不是。允许把指针本身定义为常量  
* **常量指针**必须初始化，且一旦初始化完成，它的值(即指向对象的地址)就不能再改变了
* 把*放在const之前说明指针是一个常量，即**不变的是指针**而不是指向的那个值
  ```c++
  int err = 0;
  int* const cur = &err;//cur将一直指向err
  const int pi = 3;
  const int* const pip = &pi;//pip是一个指向常量对象的常量指针
  ```
## 3.顶层const
如前所述，指针本身是一个对象，又可以指向另外一个对象。因此，指针本身是不是常量和指针指向的对象是不是常量是两个相互独立的问题。
* **顶层const**，表示指针本身是个常量
* **底层const**，表示指针指向的对象是一个常量  
 
更一般的，顶层const可以表示任意的对象是常量，这一点对于任意数据类型都适用；而底层const则与引用和指针等复合类型的基本类型部分有关。比较特殊的是，指针类型既可以是顶层const也可以是底层const：
```c++
int i = 0;
int* const p1 = &i;   //顶层const，不能改变p1的值
const int ci = 42;    //顶层const，不能改变ci的值
const int* p2 = &ci;  //底层const，可以改变p2的值
const int* const p3 = p2;//右const为顶层，左const为底层
const int& r = ci;    //用于声明引用的const都为底层const
```
顶层const对对象的拷贝一般无影响，因为拷贝不会改变对象的值
但是底层const的限制不能忽视：
* 当执行对象的拷贝操作时，拷入和拷出的对象必须具有相同的底层const资格或者两个对象的数据类型可以转换
* 一般来说，**非常量可以转换为常量，而反之不行**
```c++
int* p = p3;        //错误：p3有底层const，而p没有
p2 = p3;            //正确：都有底层const
p2 = &i;            //正确：int*能转换为const int*
int& r = ci;        //错误: 普通int&无法绑定到const int上
const int& r2 = i;  //正确：const int&可以绑定到int上
```
***
## 4.constexpr和常量表达式